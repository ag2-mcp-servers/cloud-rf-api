# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:12:11+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity

from models import (
    AreaPostRequest,
    ClutterAddPostRequest,
    Fmt,
    PathPostRequest,
    PointsPostRequest,
)

app = MCPProxy(
    contact={'email': 'support@cloudrf.com'},
    description='Use this JSON API to build and test radio links for any radio, anywhere. Authenticate with your API2.0 key in the request header as key',
    termsOfService='https://cloudrf.com/terms-and-conditions/',
    title='Cloud-RF API',
    version='2.0.0',
    servers=[{'url': 'https://api.cloudrf.com'}],
)


@app.get(
    '/archive/delete',
    description=""" Warning! you could lose data. This function will delete the entry from the database and the file from the disk. Accidental deletion can be reversed by contacting support with biscuits who maintain an offsite backup. """,
    tags=['calculation_management'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def delete(cid: int):
    """
    Delete a calculation from the database.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/archive/delete/network',
    description=""" Warning! you could lose data. This function will delete the entry from the database and the file from the disk. Accidental deletion can be reversed by contacting support with biscuits who maintain an offsite backup. """,
    tags=['network_operations'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def delete_network(nid: str):
    """
    Delete an entire network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/archive/export',
    description=""" Download your data in a format suitable for a third party viewer like Google Earth or ESRI Arcmap. """,
    tags=['data_exportation'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def export(file: str, fmt: Fmt = ...):
    """
    Export a calculation in a GIS file format
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/archive/list',
    description=""" List your area and path calculations, sorted by time and limited to the last few hundred. To fetch all for a given network append a 'net' filter with the network name. """,
    tags=['calculation_management', 'data_exportation'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def list(
    n: Optional[float] = None,
    e: Optional[float] = None,
    s: Optional[float] = None,
    w: Optional[float] = None,
):
    """
    List calculations from your archive
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/area',
    description=""" An area coverage assumes the same receiver height at all locations out to fixed radius (maximum 300km). Due to it's exhaustive processing it is the slowest of all the API calls. Speed can be improved significantly by adjusting the resolution 'res' parameter. A basic request needs transmitter, receiver, antenna and output objects defined as a minimum. Model and environment options will enhance accuracy. """,
    tags=['heatmap_creation'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def area(body: AreaPostRequest):
    """
    Create a point-to-multipoint heatmap
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/clutter/add',
    description=""" Upload GeoJSON lineString and polygon features to your account. The height property is in metres and the material code / type / attenuation are.. 1	Trees –	0.25,2Trees +	0.5,3	Timber –	1.0,4	Timber +	1.5,5	Brick – 	1.5,6	Brick +	2.0,7	Concrete –	3.0,8	Concrete +	4.0,9	Metal	6.0 """,
    tags=['clutter_data_handling', 'data_exportation'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def add_clutter(body: ClutterAddPostRequest):
    """
    Upload clutter data as GeoJSON
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/interference',
    description=""" Merge and analyse sites within a network channel to determine the best server at a given location. Each site will be dynamically allocated a monochrome colour from a palette and the strongest signal promoted at a given location. """,
    tags=['network_operations'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def interference(network: str, name: str = ...):
    """
    Find the best server for overlapping coverage
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/mesh',
    description=""" A merge of 'area' calculations for a network to create a single super layer. Stronger signals are promoted over weaker ones. The same colour key must be used. """,
    tags=['network_operations'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def mesh(network: str, name: str = ...):
    """
    Merge sites into a super layer.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network',
    description=""" Query your network to find the best server(s) for a given receiver/customer location. A previously generated network is required. """,
    tags=['network_operations'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def network(
    net: str,
    nam: str = ...,
    lat: float = ...,
    lon: float = ...,
    alt: int = ...,
    rxg: Optional[float] = None,
):
    """
    Find the best server for somewhere
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/path',
    description=""" A path profile is a single link from A to B. It is much faster than an area calculation and can be used out to 300km. A basic request needs transmitter, receiver, antenna and output objects defined as a minimum. Model and environment options will enhance accuracy. """,
    tags=['path_profile_analysis'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def path(body: PathPostRequest):
    """
    Point-to-point path profile analysis (Tx to Rx)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/points',
    description=""" The points function tests many transmitters and one receiver and is designed for route analysis. A minimal request needs a transmitters array of (latitude,longitude,altitude) locations, antenna, receiver and output objects defined as a minimum. Model and environment options will enhance accuracy. """,
    tags=['path_profile_analysis', 'network_operations'],
    security=[
        APIKeyHeader(name="key"),
    ],
)
def points(body: PointsPostRequest):
    """
    Point-to-multipoint path profile analysis (Many Tx, one Rx)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
